## Baekjoon

<details>
  <summary>Week 01</summary>
    <div>

### 구현
> 1주차 (2024.04.16 - 2024.04.23)

1. 셀프넘버
    - 일자: 2024.04.09
    - 고민: 5분
    - 코딩: 15분
    - 설명
        1. 오랜만에 풀다보니 효율성을 고려하지 않음
        2. 처음에 self_number 함수 만들어서 1부터 10000까지 출력하였더니 시간초과
        3. 생각해보니 10000보다 작은 수에서 self_number만 찾아서 나중에 빼면 되겠다 싶어서 set() 사용
        4. 다행히 기본 함수들은 금방금방 기억하는 중
        
2. 스택
    - 일자: 2024.04.12
    - 고민: 2분
    - 코딩: 20분
    - 설명
        1. import sys 후 sys.stdin.readline() 까먹어서 보고함
        2. 스택이 비어있을 경우를 자꾸 생각 안 함
        3. 쉬웠음


3. 분수찾기
    - 일자: 2024.04.12
    - 고민: 10분
    - 코딩: 21분
    - 설명
        1. 이런 게 생각이 잘 안 남 -> n까지의 합을 계산해서 구하고자 하는 x와 비교하는 방향
        2. 다른 사람 코드도 비슷한 아이디어였으나, sum을 굳이 n * (n-1) / 2로 생각하는 복잡한 방식이 아니라, while로 더해가면서 품
        3. 이러니 머리가 바보같지
        4. print는 f-string 쓴 사람도 있고, sep인자 공백으로 해서 붙인 사람도 있고


4. 덩치
    - 일자: 2024.04.15
    - 고민: 2분
    - 코딩: 30분 -> 오답으로 답 봄
    - 설명
        1. 괜히 딕셔너리로 보려고 했었음
        2. 근데 아마 순서가 틀어진듯


5. 덱
    - 일자: 2024.04.16
    - 고민: 3분
    - 코딩: 23분
    - 설명
        1. deque 쓰기
        2. 오타, 실수 찾기 위해서 하나씩 구현하는 게 맞는 듯


6. 요세푸스 문제
    - 일자: 2024.04.16
    - 고민: 20분
    - 코딩: 10분
    - 설명
        1. 나머지, 몫을 활용해서 인덱싱하는 것을 최대한 활용하려고 고민을 길게 함
        2. 이런 유형은 항상 그런 인덱싱을 잘 써야 되는 것 같아서
        3. 그리고 예외사항 고려를 나름 바로 잘 해서 잘 푼 것 같음

</details>


<details>
  <summary>Week 02</summary>
    <div>

### 구현
> 2주차 (2024.04.16 - 2024.04.23)

1. 색종이
    - 일자: 2024.04.17
    - 고민: 30분
    - 코딩: 5분
    - 설명
        1. 수학적으로 풀려고 한참 생각하다가 좌표를 하나씩 칠하는 개념으로 생각함
        2. 코드 구현은 간단했음


2. 프린터 큐
    - 일자: 2024.04.17
    - 고민: 5분
    - 코딩: 20분
    - 설명
        1. 큐 쓰는 것은 쉬웠으나, dq가 비냐 안 비냐를 체크 안 해서 1차 문제 발생
        2. and 조건의 위치에 따라 오류가 발생한다는 점을 생각 못해서 2차 문제 발생


3. 통계학
    - 일자: 2024.04.17
    - 고민: 1분
    - 코딩: 15분
    - 설명
        1. mode 구현만 조금 생각할 필요 있었는데, 그마저도 Counter 쓰면 쉬웠음.
        2. 심지어 most_common() 함수까지 쓰면 더 쉬운듯


4. 방 번호
    - 일자: 2024.04.17
    - 고민: 6분
    - 코딩: 8분
    - 설명
        1. 방 번호 6, 9는 6으로 딕셔너리에 몰아넣고, 9라는 키는 빼버림
        2. 나머지 숫자는 += 1로 추가
        3. 6이라는 키는 (6, 9)의 숫자를 포함하고 있기 때문에, 2로 나누어주어야 함. 
        4. 그런데, 다른 숫자와 다르게 한 세트를 쓰면 6이라는 숫자는 2로 나누기 전에 1을 더해서 나누어 주어야 함.
        5. 그 이유는, 설명을 잘 못하겠는데, 몫을 맞추기 위해서 그렇게 함.


### DFS
> 2주차 (2024.04.16 - 2024.04.23)
1. 안전 영역
    - 일자: 2024.04.22
    - 고민: 5분
    - 코딩: 30분 (초과)
    - 설명
        1. DFS 오랜만에 풀다가 답안 참고
        2. 방법을 다시 상기시킬 수 있었음 (visited 사용, 노드 타는 조건 등)


</details>



<details>
  <summary>Week 03</summary>
    <div>

### 구현
> 3주차 (2024.04.23 - 2024.05.01)

1. 숫자 정사각형
    - 일자: 2024.04.25
    - 고민: 7분
    - 코딩: 13분
    - 설명
        1. 50*50*50 돌리는 완전탐색으로도 충분해서 완전탐색 진행
        2. 네 꼭지점이 같은 수를 체크하는 것이 중요해서 인덱싱에 신경 씀
        3. 하지만 처음에 n, m 중에 작은 수가 1인 경우를 고려하지 못함

    - 답안 검색
        1. == 조건 한 번에 여러 개 써도 되는구나
        2. 생각해보니 시간복잡도를 줄이려면 큰 수부터 출발하는 것이 방법이겠네


2. 숫자 야구
    - 일자: 2024.04.25
    - 고민: 20분
    - 코딩: 20분 (시간초과하여 답안 확인)
    - 설명
        - s, b 경우의 수 10개를 모두 코딩할 방안을 생각하다가 아닌 것 같아서 멈춤
        - 우선 숫자를 순열로 구해야하는데 조합으로 생각한 실수
        - 무엇보다 10가지 경우를 모두 코딩하는 것이 아니라 전체 숫자 순열 내에서 반복문을 돌리면서 그 숫자와 질문숫자를 비교하여 스트라이크 수와 볼 수를 계산하는 방법이 중요했음
        - 자료형은 리스트 등을 쓸 경우 문제가 인덱싱 개수가 줄어들어서 문제가 발생함 -> 인덱스를 지워준 개수만큼 빼서 맞춰주는 스킬을 많이들 씀
        - 근데 내 생각에는 딕셔너리 쓰는 것도 괜찮을 듯 (시간은 조금 더 걸림)


3. 한 줄로 서기
    - 일자: 2024.04.29
    - 고민: 14분
    - 코딩: 2분
    - 설명
        1. 인덱스 리스트를 만들어서 지우는 방식으로 진행
        2. 지우기 위해 new라는 변수를 만들어서 인덱스 위치를 업데이트 함
    - 답안 비교
        - input인 키순서 리스트 자체에서 인덱스를 비교하며 결과 리스트의 자리가 비어있고, 리스트 인덱스의 숫자와 카운트가 같으면 그 자리에 업데이트 하는 방식을 씀
        - 이중반복


### DP
> 3주차 (2024.04.23 - 2024.05.01)
1. 1, 2, 3 더하기
    - 일자: 2024.04.30
    - 고민: 10분
    - 코딩: 답안 봄
    - 설명
        1. dp 개념 생각 안 나서 답 봄
        2. 점화식 개념 기억함. 리스트에 저장하는 식으로 푼 사람 답안 봄
        3. 점화식 빼는 방식으로 가는 방법 공부해야겠음

### 그리디
> 3주차 (2024.04.23 - 2024.05.01)
1. ATM
    - 일자: 2024.04.30
    - 고민: 5분
    - 코딩: 1분
    - 설명
        1. 너무 쉬움.  정렬하면 끝

    - 답안 비교
        - 리스트 하나 더 안 만들고 cnt에 sum(time[:i])를 + 하여 답안을 업데이트 함



</details>



<details>
  <summary>Week 04</summary>
    <div>

### 구현
> 4주차 (2024.05.02 - 2024.05.08)

1. 트럭
    - 일자: 2024.05.02
    - 고민: 18분
    - 코딩: 2분
    - 설명
        1. 프로그래머스에서 옛날에 조금 더 어려운 문제 풀었던 기억나서 큐를 사용
        2. 인덱싱 사용할 때 빈 큐가 나오면 안되므로 while 조건과 while문 안에서의 조건을 잘 고려하고자 하여 한번에 풀 수 있었음

    - 답안 비교
        1. 난 트럭 무게도 큐로 저장했는데, 트럭 무게는 인덱싱으로 인덱스 숫자를 업데이트하며 푼 사람도 있음
        2. 1의 방법을 쓴 분은 트럭의 인덱스를 살펴볼 때까지 다 보고 난 후, 다리 위 남은 트럭이 지나가는 것을 카운트하기 위해 두번째 while문을 짜서 함


2. 치킨 배달
    - 일자: 2024.05.
    - 고민: 15분
    - 코딩: 7분
    - 설명
        1. 치킨집과 집의 좌표만 저장하고 치킨집 좌표의 조합을 고르면 된다고 생각
        2. 조합 만들고 - 집을 하나 픽하고 - 집과 조합 내 좌표 거리 구해서 집별로 가장 가까운 치킨집 거리 total_dist에 업데이트 하고, 조합별 MIN 찾음
        3. 중간에 현재 MIN보다 total_dist가 크면 break 조건 넣으면 속도는 더 빨라질 듯 하나 굳이 안 넣어도 통과함
    
    - 답안 비교
        - dfs로 타고 들어간 사람들 답안이 빨랐음
        - 모든 집과 치킨 사이의 거리를 다 계산해서 (거리, 치킨집 인덱스)로 저장해놓고 정렬 후 해당 리스트를 타고 들어가면서 visited로는 방문한 치킨집인지를 체크
        - depth == M이면 현재 기록된 (visited가 True인 치킨집만) 치킨집과 집 사이 거리를 더해서 업데이트하고 ans값과 비교
        - 이렇게 노드 타고 들어갈 거 생각하니 꽤 빡세네
    



### DP
> 4주차 (2024.05.02 - 2024.05.08)
1. RGB 거리
    - 일자: 2024.05.03
    - 고민: 15분
    - 코딩: 15분 (답봄)
    - 설명
        1. 코딩 전에 생각했어야 했는데 재귀함수로 푸는 연습을 해야할 것 같아서 재귀함수로 했다가 나중에 생각해보니 시간복잡도가 2^n이었다..
        2. 그래도 코드는 맞게 돌아가도록 구현했다
        3. 재귀함수는 좋지 않다는 것을 상기할 수 있었다
    
    - 답안 비교
        - 굉장히 간단하지만 나는 풀면서 전혀 생각 못한 방식인데, input으로 받은 cost 리스트를 업데이트하는 방식으로 진행
        - 이전 행에서 자신과 다른 인덱스를 더하되, 둘 중에 최솟값을 더하면서 반복하면 최종적으로 최솟값을 쉽게 구할 수 있음


### DFS/BFS
> 4주차 (2024.05.02 - 2024.05.08)
1. 영역 구하기
    - 일자: 2024.05.08
    - 고민: 15분
    - 코딩: 20분
    - 설명
        1. dfs로 풀다가 답은 나왔으나 recursion error 뜸
        2. 그래서 bfs로 전환해서 코딩해서 시간 더 걸림. 하지만 오랜만에 bfs 짰음에도 잘 짬
        3. 깊이가 깊을 거 같으면 되도록 bfs를 쓰도록 하자
        4. 좌표 -> 넓이로 직관적으로 치환이 되지 않아서 고민 시간이 조금 더 걸렸다

    - 답안 비교
        - 큰 차이는 없었다

2. 촌수계산
    - 일자: 2024.05.09
    - 고민: 10분
    - 코딩: 30분
    - 설명
        1. 최대 100명이라 dfs보다 bfs로 푸는게 빠를 것 같았는데 dfs도 괜찮은 모양
        2. bfs에서 append할 때 노드 인덱스와 촌수를 튜플로 같이 업데이트 하는 식으로 해결
    
    - 답안 비교
        - dfs로 푼 사람들을 보니 촌수 노드가 비어있는 것은 고려하지 않음
        - 난 혹시나 가족관계가 없는 노드도 있을까봐 그것을 추가했는데 빼고 해보니 됐음


</details>






<details>
  <summary>Week 04</summary>
    <div>

### 구현
> 5주차 (2024.05.09 - 2024.05.16)

1. 로봇청소기
    - 일자: 2024.05.10
    - 알고리즘: 구현
    - 고민: 10분
    - 코딩: 35분
    - 설명
        1. bfs처럼 queue를 활용하면서도, 각각의 움직임에 대해서 딕셔너리로 정의해서 움직임
        2. deque에 (x좌표, y좌표, 방향)을 추가하면서 업데이트 하려고 했는데 자꾸 방향을 빼먹어서 틀림
        3. 반복문에 들어간 변수명을 실제 변수명이랑 혼용해서 써서도 오류 자꾸 났으나 찾아서 해결
        4. 처음에 x, y 좌표의 index를 dfs/bfs 평소에 할 때처럼 0 <= nx < N, 0 <= ny < M 이런 식으로 제한해서 하니까 24% 쯤에서 틀림
        5. 질문게시판을 보니까 이 인덱스 제한을 풀라고 해서 이 조건만 지우고 해봤더니 완전히 해결됐음.
        6. 그리고 인덱스 제한을 0 <= nx <= N 으로 하면 또 됨,, 근데 왜 되고, 왜 안 되는지 모르겠음

    - 답안 비교
        1. turn_moving을 나처럼 딕셔너리로 설정하지 않고, 나머지로 하는 방법
        2. 내 방법이 더 직관적이나, 수학적이지는 않아서 아쉬움


2. 정수 삼각형
    - 일자: 2024.05.1
    - 알고리즘: DP
    - 고민: 20분
    - 코딩: 15분
    - 설명
        1. 전에 풀었던 RGB거리처럼 리스트를 업데이트 해가면서 푸는 방식을 고민
        2. 인덱싱이 헷갈려서 전체 과정을 직접 손으로 쓴 뒤, 맞춰가면서 코딩함

    - 답안 비교
        - 똑같이 0번째 열, 마지막 열, 나머지 열을 구분하여 조건문으로 해결
        - 다만, 처음부터 전부 input을 다 dp라는 리스트에 저장해놓고 불러오면서, 이전 행을 확인하니 인덱싱이 더 깔끔하고 쉬워보임
    

3. 카드 합체 놀이
    - 일자: 2024.05.13
    - 알고리즘: 힙/우선순위 큐
    - 고민: 5분
    - 코딩: 5분
    - 설명
        1. 힙을 사용하여 가장 작은 숫자 두 번 뽑도록 함
        2. 힙이 스왑을 활용한 정렬에 활용하는 자료구조라는데 이에 대한 이해가 부족한 것 같음 공부 필요

    - 답안 비교
        - 정렬로 풀기, heapify로 풀기, heappush로 정렬 직접하기


4. 외계인의 기타 연주
    - 일자: 2024.05.
    - 알고리즘: 스택
    - 고민: 
    - 코딩: 
    - 설명
        1. 
    - 답안 비교
        - 


5. LCS
    - 일자: 2024.05.
    - 알고리즘: 문자열
    - 고민: 
    - 코딩: 
    - 설명
        1. 
    - 답안 비교
        - 



</details>