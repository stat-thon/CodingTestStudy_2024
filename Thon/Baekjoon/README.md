## Baekjoon

<details>
  <summary>Week 01</summary>
    <div>

### 구현
> 1주차 (2024.04.16 - 2024.04.23)

1. 셀프넘버
    - 일자: 2024.04.09
    - 고민: 5분
    - 코딩: 15분
    - 설명
        1. 오랜만에 풀다보니 효율성을 고려하지 않음
        2. 처음에 self_number 함수 만들어서 1부터 10000까지 출력하였더니 시간초과
        3. 생각해보니 10000보다 작은 수에서 self_number만 찾아서 나중에 빼면 되겠다 싶어서 set() 사용
        4. 다행히 기본 함수들은 금방금방 기억하는 중
        
2. 스택
    - 일자: 2024.04.12
    - 고민: 2분
    - 코딩: 20분
    - 설명
        1. import sys 후 sys.stdin.readline() 까먹어서 보고함
        2. 스택이 비어있을 경우를 자꾸 생각 안 함
        3. 쉬웠음


3. 분수찾기
    - 일자: 2024.04.12
    - 고민: 10분
    - 코딩: 21분
    - 설명
        1. 이런 게 생각이 잘 안 남 -> n까지의 합을 계산해서 구하고자 하는 x와 비교하는 방향
        2. 다른 사람 코드도 비슷한 아이디어였으나, sum을 굳이 n * (n-1) / 2로 생각하는 복잡한 방식이 아니라, while로 더해가면서 품
        3. 이러니 머리가 바보같지
        4. print는 f-string 쓴 사람도 있고, sep인자 공백으로 해서 붙인 사람도 있고


4. 덩치
    - 일자: 2024.04.15
    - 고민: 2분
    - 코딩: 30분 -> 오답으로 답 봄
    - 설명
        1. 괜히 딕셔너리로 보려고 했었음
        2. 근데 아마 순서가 틀어진듯


5. 덱
    - 일자: 2024.04.16
    - 고민: 3분
    - 코딩: 23분
    - 설명
        1. deque 쓰기
        2. 오타, 실수 찾기 위해서 하나씩 구현하는 게 맞는 듯


6. 요세푸스 문제
    - 일자: 2024.04.16
    - 고민: 20분
    - 코딩: 10분
    - 설명
        1. 나머지, 몫을 활용해서 인덱싱하는 것을 최대한 활용하려고 고민을 길게 함
        2. 이런 유형은 항상 그런 인덱싱을 잘 써야 되는 것 같아서
        3. 그리고 예외사항 고려를 나름 바로 잘 해서 잘 푼 것 같음

</details>


<details>
  <summary>Week 02</summary>
    <div>

### 구현
> 2주차 (2024.04.16 - 2024.04.23)

1. 색종이
    - 일자: 2024.04.17
    - 고민: 30분
    - 코딩: 5분
    - 설명
        1. 수학적으로 풀려고 한참 생각하다가 좌표를 하나씩 칠하는 개념으로 생각함
        2. 코드 구현은 간단했음


2. 프린터 큐
    - 일자: 2024.04.17
    - 고민: 5분
    - 코딩: 20분
    - 설명
        1. 큐 쓰는 것은 쉬웠으나, dq가 비냐 안 비냐를 체크 안 해서 1차 문제 발생
        2. and 조건의 위치에 따라 오류가 발생한다는 점을 생각 못해서 2차 문제 발생


3. 통계학
    - 일자: 2024.04.17
    - 고민: 1분
    - 코딩: 15분
    - 설명
        1. mode 구현만 조금 생각할 필요 있었는데, 그마저도 Counter 쓰면 쉬웠음.
        2. 심지어 most_common() 함수까지 쓰면 더 쉬운듯


4. 방 번호
    - 일자: 2024.04.17
    - 고민: 6분
    - 코딩: 8분
    - 설명
        1. 방 번호 6, 9는 6으로 딕셔너리에 몰아넣고, 9라는 키는 빼버림
        2. 나머지 숫자는 += 1로 추가
        3. 6이라는 키는 (6, 9)의 숫자를 포함하고 있기 때문에, 2로 나누어주어야 함. 
        4. 그런데, 다른 숫자와 다르게 한 세트를 쓰면 6이라는 숫자는 2로 나누기 전에 1을 더해서 나누어 주어야 함.
        5. 그 이유는, 설명을 잘 못하겠는데, 몫을 맞추기 위해서 그렇게 함.


### DFS
> 2주차 (2024.04.16 - 2024.04.23)
1. 안전 영역
    - 일자: 2024.04.22
    - 고민: 5분
    - 코딩: 30분 (초과)
    - 설명
        1. DFS 오랜만에 풀다가 답안 참고
        2. 방법을 다시 상기시킬 수 있었음 (visited 사용, 노드 타는 조건 등)


</details>



<details>
  <summary>Week 03</summary>
    <div>

### 구현
> 3주차 (2024.04.23 - 2024.05.01)

1. 숫자 정사각형
    - 일자: 2024.04.25
    - 고민: 7분
    - 코딩: 13분
    - 설명
        1. 50*50*50 돌리는 완전탐색으로도 충분해서 완전탐색 진행
        2. 네 꼭지점이 같은 수를 체크하는 것이 중요해서 인덱싱에 신경 씀
        3. 하지만 처음에 n, m 중에 작은 수가 1인 경우를 고려하지 못함

    - 답안 검색
        1. == 조건 한 번에 여러 개 써도 되는구나
        2. 생각해보니 시간복잡도를 줄이려면 큰 수부터 출발하는 것이 방법이겠네


2. 숫자 야구
    - 일자: 2024.04.25
    - 고민: 20분
    - 코딩: 20분 (시간초과하여 답안 확인)
    - 설명
        - s, b 경우의 수 10개를 모두 코딩할 방안을 생각하다가 아닌 것 같아서 멈춤
        - 우선 숫자를 순열로 구해야하는데 조합으로 생각한 실수
        - 무엇보다 10가지 경우를 모두 코딩하는 것이 아니라 전체 숫자 순열 내에서 반복문을 돌리면서 그 숫자와 질문숫자를 비교하여 스트라이크 수와 볼 수를 계산하는 방법이 중요했음
        - 자료형은 리스트 등을 쓸 경우 문제가 인덱싱 개수가 줄어들어서 문제가 발생함 -> 인덱스를 지워준 개수만큼 빼서 맞춰주는 스킬을 많이들 씀
        - 근데 내 생각에는 딕셔너리 쓰는 것도 괜찮을 듯 (시간은 조금 더 걸림)


3. 한 줄로 서기
    - 일자: 2024-04-29
    - 고민: 14분
    - 코딩: 2분
    - 설명
        1. 인덱스 리스트를 만들어서 지우는 방식으로 진행
        2. 지우기 위해 new라는 변수를 만들어서 인덱스 위치를 업데이트 함
    - 답안 비교
        - input인 키순서 리스트 자체에서 인덱스를 비교하며 결과 리스트의 자리가 비어있고, 리스트 인덱스의 숫자와 카운트가 같으면 그 자리에 업데이트 하는 방식을 씀
        - 이중반복


### DP
> 3주차 (2024.04.23 - 2024.05.01)
1. 1, 2, 3 더하기
    - 일자: 
    - 고민: 
    - 코딩: 
    - 설명
        1. 
        2. 

### 그리디
> 3주차 (2024.04.23 - 2024.05.01)
1. ATM
    - 일자: 
    - 고민: 
    - 코딩: 
    - 설명
        1. 
        2. 



</details>