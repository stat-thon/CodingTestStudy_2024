## Baekjoon

<details>
  <summary>Week 01</summary>
    <div>

### 구현
> 1주차 (2024.04.16 - 2024.04.23)

1. 셀프넘버
    - 일자: 2024.04.09
    - 고민: 5분
    - 코딩: 15분
    - 설명
        1. 오랜만에 풀다보니 효율성을 고려하지 않음
        2. 처음에 self_number 함수 만들어서 1부터 10000까지 출력하였더니 시간초과
        3. 생각해보니 10000보다 작은 수에서 self_number만 찾아서 나중에 빼면 되겠다 싶어서 set() 사용
        4. 다행히 기본 함수들은 금방금방 기억하는 중
        
2. 스택
    - 일자: 2024.04.12
    - 고민: 2분
    - 코딩: 20분
    - 설명
        1. import sys 후 sys.stdin.readline() 까먹어서 보고함
        2. 스택이 비어있을 경우를 자꾸 생각 안 함
        3. 쉬웠음


3. 분수찾기
    - 일자: 2024.04.12
    - 고민: 10분
    - 코딩: 21분
    - 설명
        1. 이런 게 생각이 잘 안 남 -> n까지의 합을 계산해서 구하고자 하는 x와 비교하는 방향
        2. 다른 사람 코드도 비슷한 아이디어였으나, sum을 굳이 n * (n-1) / 2로 생각하는 복잡한 방식이 아니라, while로 더해가면서 품
        3. 이러니 머리가 바보같지
        4. print는 f-string 쓴 사람도 있고, sep인자 공백으로 해서 붙인 사람도 있고


4. 덩치
    - 일자: 2024.04.15
    - 고민: 2분
    - 코딩: 30분 -> 오답으로 답 봄
    - 설명
        1. 괜히 딕셔너리로 보려고 했었음
        2. 근데 아마 순서가 틀어진듯


5. 덱
    - 일자: 2024.04.16
    - 고민: 3분
    - 코딩: 23분
    - 설명
        1. deque 쓰기
        2. 오타, 실수 찾기 위해서 하나씩 구현하는 게 맞는 듯


6. 요세푸스 문제
    - 일자: 2024.04.16
    - 고민: 20분
    - 코딩: 10분
    - 설명
        1. 나머지, 몫을 활용해서 인덱싱하는 것을 최대한 활용하려고 고민을 길게 함
        2. 이런 유형은 항상 그런 인덱싱을 잘 써야 되는 것 같아서
        3. 그리고 예외사항 고려를 나름 바로 잘 해서 잘 푼 것 같음

</details>


<details>
  <summary>Week 02</summary>
    <div>

### 구현
> 2주차 (2024.04.16 - 2024.04.23)

1. 색종이
    - 일자: 2024.04.17
    - 고민: 30분
    - 코딩: 5분
    - 설명
        1. 수학적으로 풀려고 한참 생각하다가 좌표를 하나씩 칠하는 개념으로 생각함
        2. 코드 구현은 간단했음


2. 프린터 큐
    - 일자: 2024.04.17
    - 고민: 5분
    - 코딩: 20분
    - 설명
        1. 큐 쓰는 것은 쉬웠으나, dq가 비냐 안 비냐를 체크 안 해서 1차 문제 발생
        2. and 조건의 위치에 따라 오류가 발생한다는 점을 생각 못해서 2차 문제 발생


3. 통계학
    - 일자: 2024.04.17
    - 고민: 1분
    - 코딩: 15분
    - 설명
        1. mode 구현만 조금 생각할 필요 있었는데, 그마저도 Counter 쓰면 쉬웠음.
        2. 심지어 most_common() 함수까지 쓰면 더 쉬운듯


4. 방 번호
    - 일자: 2024.04.17
    - 고민: 6분
    - 코딩: 8분
    - 설명
        1. 방 번호 6, 9는 6으로 딕셔너리에 몰아넣고, 9라는 키는 빼버림
        2. 나머지 숫자는 += 1로 추가
        3. 6이라는 키는 (6, 9)의 숫자를 포함하고 있기 때문에, 2로 나누어주어야 함. 
        4. 그런데, 다른 숫자와 다르게 한 세트를 쓰면 6이라는 숫자는 2로 나누기 전에 1을 더해서 나누어 주어야 함.
        5. 그 이유는, 설명을 잘 못하겠는데, 몫을 맞추기 위해서 그렇게 함.


### DFS
> 2주차 (2024.04.16 - 2024.04.23)
1. 안전 영역
    - 일자: 2024.04.22
    - 고민: 5분
    - 코딩: 30분 (초과)
    - 설명
        1. DFS 오랜만에 풀다가 답안 참고
        2. 방법을 다시 상기시킬 수 있었음 (visited 사용, 노드 타는 조건 등)


</details>



<details>
  <summary>Week 03</summary>
    <div>

### 구현
> 3주차 (2024.04.23 - 2024.05.01)

1. 숫자 정사각형
    - 일자: 2024.04.25
    - 고민: 7분
    - 코딩: 13분
    - 설명
        1. 50*50*50 돌리는 완전탐색으로도 충분해서 완전탐색 진행
        2. 네 꼭지점이 같은 수를 체크하는 것이 중요해서 인덱싱에 신경 씀
        3. 하지만 처음에 n, m 중에 작은 수가 1인 경우를 고려하지 못함

    - 답안 검색
        1. == 조건 한 번에 여러 개 써도 되는구나
        2. 생각해보니 시간복잡도를 줄이려면 큰 수부터 출발하는 것이 방법이겠네


2. 숫자 야구
    - 일자: 2024.04.25
    - 고민: 20분
    - 코딩: 20분 (시간초과하여 답안 확인)
    - 설명
        - s, b 경우의 수 10개를 모두 코딩할 방안을 생각하다가 아닌 것 같아서 멈춤
        - 우선 숫자를 순열로 구해야하는데 조합으로 생각한 실수
        - 무엇보다 10가지 경우를 모두 코딩하는 것이 아니라 전체 숫자 순열 내에서 반복문을 돌리면서 그 숫자와 질문숫자를 비교하여 스트라이크 수와 볼 수를 계산하는 방법이 중요했음
        - 자료형은 리스트 등을 쓸 경우 문제가 인덱싱 개수가 줄어들어서 문제가 발생함 -> 인덱스를 지워준 개수만큼 빼서 맞춰주는 스킬을 많이들 씀
        - 근데 내 생각에는 딕셔너리 쓰는 것도 괜찮을 듯 (시간은 조금 더 걸림)


3. 한 줄로 서기
    - 일자: 2024.04.29
    - 고민: 14분
    - 코딩: 2분
    - 설명
        1. 인덱스 리스트를 만들어서 지우는 방식으로 진행
        2. 지우기 위해 new라는 변수를 만들어서 인덱스 위치를 업데이트 함
    - 답안 비교
        - input인 키순서 리스트 자체에서 인덱스를 비교하며 결과 리스트의 자리가 비어있고, 리스트 인덱스의 숫자와 카운트가 같으면 그 자리에 업데이트 하는 방식을 씀
        - 이중반복


### DP
> 3주차 (2024.04.23 - 2024.05.01)
1. 1, 2, 3 더하기
    - 일자: 2024.04.30
    - 고민: 10분
    - 코딩: 답안 봄
    - 설명
        1. dp 개념 생각 안 나서 답 봄
        2. 점화식 개념 기억함. 리스트에 저장하는 식으로 푼 사람 답안 봄
        3. 점화식 빼는 방식으로 가는 방법 공부해야겠음

### 그리디
> 3주차 (2024.04.23 - 2024.05.01)
1. ATM
    - 일자: 2024.04.30
    - 고민: 5분
    - 코딩: 1분
    - 설명
        1. 너무 쉬움.  정렬하면 끝

    - 답안 비교
        - 리스트 하나 더 안 만들고 cnt에 sum(time[:i])를 + 하여 답안을 업데이트 함



</details>



<details>
  <summary>Week 04</summary>
    <div>

### 구현
> 4주차 (2024.05.02 - 2024.05.08)

1. 트럭
    - 일자: 2024.05.02
    - 고민: 18분
    - 코딩: 2분
    - 설명
        1. 프로그래머스에서 옛날에 조금 더 어려운 문제 풀었던 기억나서 큐를 사용
        2. 인덱싱 사용할 때 빈 큐가 나오면 안되므로 while 조건과 while문 안에서의 조건을 잘 고려하고자 하여 한번에 풀 수 있었음

    - 답안 비교
        1. 난 트럭 무게도 큐로 저장했는데, 트럭 무게는 인덱싱으로 인덱스 숫자를 업데이트하며 푼 사람도 있음
        2. 1의 방법을 쓴 분은 트럭의 인덱스를 살펴볼 때까지 다 보고 난 후, 다리 위 남은 트럭이 지나가는 것을 카운트하기 위해 두번째 while문을 짜서 함


2. 치킨 배달
    - 일자: 2024.05.
    - 고민: 15분
    - 코딩: 7분
    - 설명
        1. 치킨집과 집의 좌표만 저장하고 치킨집 좌표의 조합을 고르면 된다고 생각
        2. 조합 만들고 - 집을 하나 픽하고 - 집과 조합 내 좌표 거리 구해서 집별로 가장 가까운 치킨집 거리 total_dist에 업데이트 하고, 조합별 MIN 찾음
        3. 중간에 현재 MIN보다 total_dist가 크면 break 조건 넣으면 속도는 더 빨라질 듯 하나 굳이 안 넣어도 통과함
    
    - 답안 비교
        - dfs로 타고 들어간 사람들 답안이 빨랐음
        - 모든 집과 치킨 사이의 거리를 다 계산해서 (거리, 치킨집 인덱스)로 저장해놓고 정렬 후 해당 리스트를 타고 들어가면서 visited로는 방문한 치킨집인지를 체크
        - depth == M이면 현재 기록된 (visited가 True인 치킨집만) 치킨집과 집 사이 거리를 더해서 업데이트하고 ans값과 비교
        - 이렇게 노드 타고 들어갈 거 생각하니 꽤 빡세네
    



### DP
> 4주차 (2024.05.02 - 2024.05.08)
1. RGB 거리
    - 일자: 2024.05.03
    - 고민: 15분
    - 코딩: 15분 (답봄)
    - 설명
        1. 코딩 전에 생각했어야 했는데 재귀함수로 푸는 연습을 해야할 것 같아서 재귀함수로 했다가 나중에 생각해보니 시간복잡도가 2^n이었다..
        2. 그래도 코드는 맞게 돌아가도록 구현했다
        3. 재귀함수는 좋지 않다는 것을 상기할 수 있었다
    
    - 답안 비교
        - 굉장히 간단하지만 나는 풀면서 전혀 생각 못한 방식인데, input으로 받은 cost 리스트를 업데이트하는 방식으로 진행
        - 이전 행에서 자신과 다른 인덱스를 더하되, 둘 중에 최솟값을 더하면서 반복하면 최종적으로 최솟값을 쉽게 구할 수 있음


### DFS/BFS
> 4주차 (2024.05.02 - 2024.05.08)
1. 영역 구하기
    - 일자: 2024.05.08
    - 고민: 15분
    - 코딩: 20분
    - 설명
        1. dfs로 풀다가 답은 나왔으나 recursion error 뜸
        2. 그래서 bfs로 전환해서 코딩해서 시간 더 걸림. 하지만 오랜만에 bfs 짰음에도 잘 짬
        3. 깊이가 깊을 거 같으면 되도록 bfs를 쓰도록 하자
        4. 좌표 -> 넓이로 직관적으로 치환이 되지 않아서 고민 시간이 조금 더 걸렸다

    - 답안 비교
        - 큰 차이는 없었다

2. 촌수계산
    - 일자: 2024.05.09
    - 고민: 10분
    - 코딩: 30분
    - 설명
        1. 최대 100명이라 dfs보다 bfs로 푸는게 빠를 것 같았는데 dfs도 괜찮은 모양
        2. bfs에서 append할 때 노드 인덱스와 촌수를 튜플로 같이 업데이트 하는 식으로 해결
    
    - 답안 비교
        - dfs로 푼 사람들을 보니 촌수 노드가 비어있는 것은 고려하지 않음
        - 난 혹시나 가족관계가 없는 노드도 있을까봐 그것을 추가했는데 빼고 해보니 됐음


</details>






<details>
  <summary>Week 04</summary>
    <div>

### 구현
> 5주차 (2024.05.09 - 2024.05.16)

1. 로봇청소기
    - 일자: 2024.05.
    - 알고리즘: 구현
    - 고민: 
    - 코딩: 
    - 설명
        1. 

    - 답안 비교
        1. 


2. 정수 삼각형
    - 일자: 2024.05.
    - 알고리즘: DP
    - 고민: 
    - 코딩: 
    - 설명
        1. 

    - 답안 비교
        - 
    

3. 카드 합체 놀이
    - 일자: 2024.05.
    - 알고리즘: 힙/우선순위 큐
    - 고민: 
    - 코딩: 
    - 설명
        1. 
    - 답안 비교
        - 


4. 외계인의 기타 연주
    - 일자: 2024.05.
    - 알고리즘: 스택
    - 고민: 
    - 코딩: 
    - 설명
        1. 
    - 답안 비교
        - 


5. LCS
    - 일자: 2024.05.
    - 알고리즘: 문자열
    - 고민: 
    - 코딩: 
    - 설명
        1. 
    - 답안 비교
        - 



</details>