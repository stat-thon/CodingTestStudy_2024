## Baekjoon

<details>
  <summary>Week 01</summary>
    <div>

### 구현
> 1주차 (2024.04.16 - 2024.04.23)

1. 셀프넘버
    - 일자: 2024.04.09
    - 고민: 5분
    - 코딩: 15분
    - 설명
        1. 오랜만에 풀다보니 효율성을 고려하지 않음
        2. 처음에 self_number 함수 만들어서 1부터 10000까지 출력하였더니 시간초과
        3. 생각해보니 10000보다 작은 수에서 self_number만 찾아서 나중에 빼면 되겠다 싶어서 set() 사용
        4. 다행히 기본 함수들은 금방금방 기억하는 중
        
2. 스택
    - 일자: 2024.04.12
    - 고민: 2분
    - 코딩: 20분
    - 설명
        1. import sys 후 sys.stdin.readline() 까먹어서 보고함
        2. 스택이 비어있을 경우를 자꾸 생각 안 함
        3. 쉬웠음


3. 분수찾기
    - 일자: 2024.04.12
    - 고민: 10분
    - 코딩: 21분
    - 설명
        1. 이런 게 생각이 잘 안 남 -> n까지의 합을 계산해서 구하고자 하는 x와 비교하는 방향
        2. 다른 사람 코드도 비슷한 아이디어였으나, sum을 굳이 n * (n-1) / 2로 생각하는 복잡한 방식이 아니라, while로 더해가면서 품
        3. 이러니 머리가 바보같지
        4. print는 f-string 쓴 사람도 있고, sep인자 공백으로 해서 붙인 사람도 있고


4. 덩치
    - 일자: 2024.04.15
    - 고민: 2분
    - 코딩: 30분 -> 오답으로 답 봄
    - 설명
        1. 괜히 딕셔너리로 보려고 했었음
        2. 근데 아마 순서가 틀어진듯


5. 덱
    - 일자: 2024.04.16
    - 고민: 3분
    - 코딩: 23분
    - 설명
        1. deque 쓰기
        2. 오타, 실수 찾기 위해서 하나씩 구현하는 게 맞는 듯


6. 요세푸스 문제
    - 일자: 2024.04.16
    - 고민: 20분
    - 코딩: 10분
    - 설명
        1. 나머지, 몫을 활용해서 인덱싱하는 것을 최대한 활용하려고 고민을 길게 함
        2. 이런 유형은 항상 그런 인덱싱을 잘 써야 되는 것 같아서
        3. 그리고 예외사항 고려를 나름 바로 잘 해서 잘 푼 것 같음

</details>


<details>
  <summary>Week 02</summary>
    <div>

### 구현
> 2주차 (2024.04.16 - 2024.04.23)

1. 색종이
    - 일자: 2024.04.17
    - 고민: 30분
    - 코딩: 5분
    - 설명
        1. 수학적으로 풀려고 한참 생각하다가 좌표를 하나씩 칠하는 개념으로 생각함
        2. 코드 구현은 간단했음


2. 프린터 큐
    - 일자: 2024.04.17
    - 고민: 5분
    - 코딩: 20분
    - 설명
        1. 큐 쓰는 것은 쉬웠으나, dq가 비냐 안 비냐를 체크 안 해서 1차 문제 발생
        2. and 조건의 위치에 따라 오류가 발생한다는 점을 생각 못해서 2차 문제 발생


3. 통계학
    - 일자: 2024.04.17
    - 고민: 1분
    - 코딩: 15분
    - 설명
        1. mode 구현만 조금 생각할 필요 있었는데, 그마저도 Counter 쓰면 쉬웠음.
        2. 심지어 most_common() 함수까지 쓰면 더 쉬운듯


4. 방 번호
    - 일자: 2024.04.17
    - 고민: 6분
    - 코딩: 8분
    - 설명
        1. 방 번호 6, 9는 6으로 딕셔너리에 몰아넣고, 9라는 키는 빼버림
        2. 나머지 숫자는 += 1로 추가
        3. 6이라는 키는 (6, 9)의 숫자를 포함하고 있기 때문에, 2로 나누어주어야 함. 
        4. 그런데, 다른 숫자와 다르게 한 세트를 쓰면 6이라는 숫자는 2로 나누기 전에 1을 더해서 나누어 주어야 함.
        5. 그 이유는, 설명을 잘 못하겠는데, 몫을 맞추기 위해서 그렇게 함.


### DFS
> 2주차 (2024.04.16 - 2024.04.23)
1. 안전 영역
    - 일자: 2024.04.22
    - 고민: 5분
    - 코딩: 30분 (초과)
    - 설명
        1. DFS 오랜만에 풀다가 답안 참고
        2. 방법을 다시 상기시킬 수 있었음 (visited 사용, 노드 타는 조건 등)


</details>



<details>
  <summary>Week 03</summary>
    <div>

### 구현
> 3주차 (2024.04.23 - 2024.05.01)

1. 숫자 정사각형
    - 일자: 2024.04.25
    - 고민: 7분
    - 코딩: 13분
    - 설명
        1. 50*50*50 돌리는 완전탐색으로도 충분해서 완전탐색 진행
        2. 네 꼭지점이 같은 수를 체크하는 것이 중요해서 인덱싱에 신경 씀
        3. 하지만 처음에 n, m 중에 작은 수가 1인 경우를 고려하지 못함

    - 답안 검색
        1. == 조건 한 번에 여러 개 써도 되는구나
        2. 생각해보니 시간복잡도를 줄이려면 큰 수부터 출발하는 것이 방법이겠네


2. 숫자 야구
    - 일자: 2024.04.25
    - 고민: 20분
    - 코딩: 20분 (시간초과하여 답안 확인)
    - 설명
        - s, b 경우의 수 10개를 모두 코딩할 방안을 생각하다가 아닌 것 같아서 멈춤
        - 우선 숫자를 순열로 구해야하는데 조합으로 생각한 실수
        - 무엇보다 10가지 경우를 모두 코딩하는 것이 아니라 전체 숫자 순열 내에서 반복문을 돌리면서 그 숫자와 질문숫자를 비교하여 스트라이크 수와 볼 수를 계산하는 방법이 중요했음
        - 자료형은 리스트 등을 쓸 경우 문제가 인덱싱 개수가 줄어들어서 문제가 발생함 -> 인덱스를 지워준 개수만큼 빼서 맞춰주는 스킬을 많이들 씀
        - 근데 내 생각에는 딕셔너리 쓰는 것도 괜찮을 듯 (시간은 조금 더 걸림)


3. 한 줄로 서기
    - 일자: 2024.04.29
    - 고민: 14분
    - 코딩: 2분
    - 설명
        1. 인덱스 리스트를 만들어서 지우는 방식으로 진행
        2. 지우기 위해 new라는 변수를 만들어서 인덱스 위치를 업데이트 함
    - 답안 비교
        - input인 키순서 리스트 자체에서 인덱스를 비교하며 결과 리스트의 자리가 비어있고, 리스트 인덱스의 숫자와 카운트가 같으면 그 자리에 업데이트 하는 방식을 씀
        - 이중반복


### DP
> 3주차 (2024.04.23 - 2024.05.01)
1. 1, 2, 3 더하기
    - 일자: 2024.04.30
    - 고민: 10분
    - 코딩: 답안 봄
    - 설명
        1. dp 개념 생각 안 나서 답 봄
        2. 점화식 개념 기억함. 리스트에 저장하는 식으로 푼 사람 답안 봄
        3. 점화식 빼는 방식으로 가는 방법 공부해야겠음

### 그리디
> 3주차 (2024.04.23 - 2024.05.01)
1. ATM
    - 일자: 2024.04.30
    - 고민: 5분
    - 코딩: 1분
    - 설명
        1. 너무 쉬움.  정렬하면 끝

    - 답안 비교
        - 리스트 하나 더 안 만들고 cnt에 sum(time[:i])를 + 하여 답안을 업데이트 함



</details>



<details>
  <summary>Week 04</summary>
    <div>

### 구현
> 4주차 (2024.05.02 - 2024.05.08)

1. 트럭
    - 일자: 2024.05.02
    - 고민: 18분
    - 코딩: 2분
    - 설명
        1. 프로그래머스에서 옛날에 조금 더 어려운 문제 풀었던 기억나서 큐를 사용
        2. 인덱싱 사용할 때 빈 큐가 나오면 안되므로 while 조건과 while문 안에서의 조건을 잘 고려하고자 하여 한번에 풀 수 있었음

    - 답안 비교
        1. 난 트럭 무게도 큐로 저장했는데, 트럭 무게는 인덱싱으로 인덱스 숫자를 업데이트하며 푼 사람도 있음
        2. 1의 방법을 쓴 분은 트럭의 인덱스를 살펴볼 때까지 다 보고 난 후, 다리 위 남은 트럭이 지나가는 것을 카운트하기 위해 두번째 while문을 짜서 함


2. 치킨 배달
    - 일자: 2024.05.02
    - 고민: 15분
    - 코딩: 7분
    - 설명
        1. 치킨집과 집의 좌표만 저장하고 치킨집 좌표의 조합을 고르면 된다고 생각
        2. 조합 만들고 - 집을 하나 픽하고 - 집과 조합 내 좌표 거리 구해서 집별로 가장 가까운 치킨집 거리 total_dist에 업데이트 하고, 조합별 MIN 찾음
        3. 중간에 현재 MIN보다 total_dist가 크면 break 조건 넣으면 속도는 더 빨라질 듯 하나 굳이 안 넣어도 통과함
    
    - 답안 비교
        - dfs로 타고 들어간 사람들 답안이 빨랐음
        - 모든 집과 치킨 사이의 거리를 다 계산해서 (거리, 치킨집 인덱스)로 저장해놓고 정렬 후 해당 리스트를 타고 들어가면서 visited로는 방문한 치킨집인지를 체크
        - depth == M이면 현재 기록된 (visited가 True인 치킨집만) 치킨집과 집 사이 거리를 더해서 업데이트하고 ans값과 비교
        - 이렇게 노드 타고 들어갈 거 생각하니 꽤 빡세네
    



### DP
> 4주차 (2024.05.02 - 2024.05.08)
1. RGB 거리
    - 일자: 2024.05.03
    - 고민: 15분
    - 코딩: 15분 (답봄)
    - 설명
        1. 코딩 전에 생각했어야 했는데 재귀함수로 푸는 연습을 해야할 것 같아서 재귀함수로 했다가 나중에 생각해보니 시간복잡도가 2^n이었다..
        2. 그래도 코드는 맞게 돌아가도록 구현했다
        3. 재귀함수는 좋지 않다는 것을 상기할 수 있었다
    
    - 답안 비교
        - 굉장히 간단하지만 나는 풀면서 전혀 생각 못한 방식인데, input으로 받은 cost 리스트를 업데이트하는 방식으로 진행
        - 이전 행에서 자신과 다른 인덱스를 더하되, 둘 중에 최솟값을 더하면서 반복하면 최종적으로 최솟값을 쉽게 구할 수 있음


### DFS/BFS
> 4주차 (2024.05.02 - 2024.05.08)
1. 영역 구하기
    - 일자: 2024.05.08
    - 고민: 15분
    - 코딩: 20분
    - 설명
        1. dfs로 풀다가 답은 나왔으나 recursion error 뜸
        2. 그래서 bfs로 전환해서 코딩해서 시간 더 걸림. 하지만 오랜만에 bfs 짰음에도 잘 짬
        3. 깊이가 깊을 거 같으면 되도록 bfs를 쓰도록 하자
        4. 좌표 -> 넓이로 직관적으로 치환이 되지 않아서 고민 시간이 조금 더 걸렸다

    - 답안 비교
        - 큰 차이는 없었다

2. 촌수계산
    - 일자: 2024.05.09
    - 고민: 10분
    - 코딩: 30분
    - 설명
        1. 최대 100명이라 dfs보다 bfs로 푸는게 빠를 것 같았는데 dfs도 괜찮은 모양
        2. bfs에서 append할 때 노드 인덱스와 촌수를 튜플로 같이 업데이트 하는 식으로 해결
    
    - 답안 비교
        - dfs로 푼 사람들을 보니 촌수 노드가 비어있는 것은 고려하지 않음
        - 난 혹시나 가족관계가 없는 노드도 있을까봐 그것을 추가했는데 빼고 해보니 됐음


</details>






<details>
  <summary>Week 05</summary>
    <div>

### 구현
> 5주차 (2024.05.09 - 2024.05.16)

1. 로봇청소기
    - 일자: 2024.05.10
    - 알고리즘: 구현
    - 고민: 10분
    - 코딩: 35분
    - 설명
        1. bfs처럼 queue를 활용하면서도, 각각의 움직임에 대해서 딕셔너리로 정의해서 움직임
        2. deque에 (x좌표, y좌표, 방향)을 추가하면서 업데이트 하려고 했는데 자꾸 방향을 빼먹어서 틀림
        3. 반복문에 들어간 변수명을 실제 변수명이랑 혼용해서 써서도 오류 자꾸 났으나 찾아서 해결
        4. 처음에 x, y 좌표의 index를 dfs/bfs 평소에 할 때처럼 0 <= nx < N, 0 <= ny < M 이런 식으로 제한해서 하니까 24% 쯤에서 틀림
        5. 질문게시판을 보니까 이 인덱스 제한을 풀라고 해서 이 조건만 지우고 해봤더니 완전히 해결됐음.
        6. 그리고 인덱스 제한을 0 <= nx <= N 으로 하면 또 됨,, 근데 왜 되고, 왜 안 되는지 모르겠음

    - 답안 비교
        1. turn_moving을 나처럼 딕셔너리로 설정하지 않고, 나머지로 하는 방법
        2. 내 방법이 더 직관적이나, 수학적이지는 않아서 아쉬움


2. 정수 삼각형
    - 일자: 2024.05.12
    - 알고리즘: DP
    - 고민: 20분
    - 코딩: 15분
    - 설명
        1. 전에 풀었던 RGB거리처럼 리스트를 업데이트 해가면서 푸는 방식을 고민
        2. 인덱싱이 헷갈려서 전체 과정을 직접 손으로 쓴 뒤, 맞춰가면서 코딩함

    - 답안 비교
        - 똑같이 0번째 열, 마지막 열, 나머지 열을 구분하여 조건문으로 해결
        - 다만, 처음부터 전부 input을 다 dp라는 리스트에 저장해놓고 불러오면서, 이전 행을 확인하니 인덱싱이 더 깔끔하고 쉬워보임
    

3. 카드 합체 놀이
    - 일자: 2024.05.13
    - 알고리즘: 힙/우선순위 큐
    - 고민: 5분
    - 코딩: 5분
    - 설명
        1. 힙을 사용하여 가장 작은 숫자 두 번 뽑도록 함
        2. 힙이 스왑을 활용한 정렬에 활용하는 자료구조라는데 이에 대한 이해가 부족한 것 같음 공부 필요

    - 답안 비교
        - 정렬로 풀기, heapify로 풀기, heappush로 정렬 직접하기


4. 외계인의 기타 연주
    - 일자: 2024.05.14
    - 알고리즘: 스택
    - 고민: 13분
    - 코딩: 5분
    - 설명
        1. 코드 최적화는 신경쓰지 않고 우선 조건문 중첩으로 써서 스택에 쌓거나 빼는 방식 활용
        2. 비교적 금방 풂

    - 답안 비교
        - 최적화가 안 되어서 그렇지, 풀이 자체는 유사했음
        - 시간복잡도가 높은 문제라 오래 걸렸는데, 시간 적게 걸린 상위 코드도 푸는 방식은 똑같은데 왜 차이가 날까 보니까
        - solution함수로 정의하니 빨리 풀렸음.. 함수로 정의한게 더 빨리 풀 수 있다는 것은 몰랐네


5. LCS
    - 일자: 2024.05.16
    - 알고리즘: DP
    - 고민: 20분
    - 코딩: 포기
    > 나중에 꼭 다시 풀어볼 것!
    - 답안 설명

        - 도무지 모르겠어서 바로 답 봄, DP 개념을 공부해야겠음
        1. 2차원 배열로 LCS 길이 캐시값을 저장 업데이트
        2. 이중 반복으로 확인했을 때 현 시점 i, j를 기준으로 word1[i-1] == word2[j-1]이면 같은 숫자가 있으므로 cache[i-1][j-1] 값에 1 추가한 값을 cache[i][j]에 기록
        3. 다른 경우가 중요한데, 다르면 cache[i-1][j]와 cache[i][j-1]을 비교하여 더 큰 값을 기록
        4. 그 이유는, 예를 들어 CAP와 ACA를 비교할 때
        - CAP는 AC까지만 볼 때 LCS가 1이지만
        - ACA는 CA를 봤을 때 LCS가 2임 -> 둘 중 최대값인 2를 써야 CAP와 ACA의 LCS가 결정됨
        - 이렇게 cache를 업데이트 하고 행렬의 맨 마지막값을 출력하면 LCS가 됨
        - 그나마, 이 방식은 2차원으로 업데이트 하니 이해가 감
    
    - 답안 비교 2
        1. cache에는  두번째 단어를 순회하면서 누적변수와 cache의 값을 비교하여 업데이트 하는 방향
        2. 누적변수로 cnt를 써서 첫번째 단어에 저장된 cache값을 불러오고, 같은 글자면 누적변수에 1을 더한 값을 캐시에 저장
        3. 단, 같은 글자가 나왔다고 해서 누적변수인 cnt를 업데이트 하지 않음.
        4. 이런 방식을 사용하면, 누적변수에는 이전 위치까지의 최대값을 저장하게 됨
        5. 최종적으로 cache에 저장된 값의 최대값을 출력
        - 상당히 이해가 안 됨



</details>



<details>
  <summary>Week 06</summary>
    <div>

### 구현
> 6주차 (2024.05.17 - 2024.05.22)

1. 평범한 배낭 (12865)
    - 일자: 2024.05.18
    - 알고리즘: DP
    - 고민: 25분
    - 코딩: 포기
    - 답안 설명
        1. 냅색 알고리즘이라고 함
        2. 물건의 개수를 행, 배낭의 용량을 열로 한 2중 배열 생성
        3. 이중 반복을 수행하여 현재 보고있는 물건의 무게가 해당하는 열의 용량(무게)보다 크면 담을 수 없음 -> 이전 물건에 해당하는 knapsack[i - 1][j]를 그대로 적용
        4. 물건의 무게가 더 가벼운 경우
            1) 현재물건의 무게 + knapsack[i - 1][j - 현재물건] + v를 계산
            2) 이전 물건만 담았을 때의 가치 knapsack[i - 1][j] 조회
            3) 4-1, 4-2의 결과 중 최대 가치를 저장 

    - 답안 비교 2
        - := (0월러스 연산자) : 표현식 안에서 변수를 할당하는 동시에 그 값을 반환하는 코드
        - 조건문 안에서 nv라는 변수로 v + v_bag을 할당하여 nv라는 변수를 반환하도록 함
        - 마찬가지로, 조건문 안에서 nw라는 변수로 w + w_bag을 할당하고 nw로 반환
        - .get() 메소드: 딕셔너리에서 특정 키의 값을 가져올 때 사용 -> 키가 딕셔너리 안에 존재하지 않을 때, 기본값을 반환하도록 함
        - -> get(키, 기본값) 

2. 스티커 (9465)
    - 일자: 2024.05.20
    - 알고리즘: DP
    - 고민: 30분
    - 코딩: 포기
    - 답안 설명
        1. 자꾸 점화식을 찾지 않고, 내 개념으로 풀려고 해서 못 푸는 듯
        2. DP 문제를 tabulation으로 풀기 위해서는 결국 점화식을 찾아서 맨 마지막 열을 비교하여 출력해야함
        3. 여기서 모든 고려해야 하는 케이스는 바로 0 행의 마지막 열을 업데이트 하기 위해서는 1행의 i-1번째 값 혹은 1행의 i-2번째 값 중 더 큰 값을 스티커 0행의 i번째 열과 더해주는 것
        4. max(DP[0][i - 1], DP[0][i - 2]) + stickers[1][i]

3. A와 B (12904)
    - 일자: 2024.05.21
    - 알고리즘: 문자열
    - 고민: 20분
    - 코딩: 포기
    - 답안 설명
        1. 생각을 좀만 더 할 걸 그랬다. 결과적으로 매 시행마다 뒤에 오는 문자는 A 혹은 B라는 경우로 갈라지므로, T문자에서 마지막 문자를 pop하는 것을 기본으로 가져가고
        2. 마지막 문자가 A냐 B냐에 따라 뒤집을지 말지를 결정했어야 했다.
        3. 요새 너무 생각을 대충하고 답을 보려고 하나 싶다..

4. 키 순서 (2458)
    - 일자: 2024.05.
    - 알고리즘: DFS/BFS
    - 고민: 40분
    - 코딩: 포기
    - 설명
        1. dfs이긴 하지만, 플로이드-워셜 알고리즘이라고 하는 방식을 사용해 최단거리를 구함
        2. 플로이드-워셜 알고리즘은 s점에서 e점까지 가는 최단거리를 알기 위해 중간 지점인 m을 사용해서, s-m, m-e의 최단 거리를 구하는 알고리즘으로 시간복잡도는 O(V^3)
        3. s-m, m-e가 모두 1인 경우 graph[s][e] = 1로 지정해주어야 함
        4. 이 때, 중간지점인 m을 지나치는 경로에 대한 for문이 반복문 중 가장 상위여야 모든 경우가 누락되지 않음. 왜냐면, 모든 경로를 다 훑어봐야 하기 때문.
        5. 근데 플로이드-워셜 안 쓰고도 visited[i][j] == 1 or visited[j][i] == 1인 경우 카운트를 추가해서 카운트가 N과 같아지면 answer에 추가하는 방식이 더 빠름;


5. 톱니바퀴 (14891)
    - 일자: 2024.06.20
    - 알고리즘: 구현
    - 고민: 20분
    - 코딩: 40분
    - 답안 설명
        1. 처음 봤을 때는 쉬워보였는데 생각보다 구현이 여러가지를 고려해서 해야하다보니 시간이 점차 오래 걸려서 답 봄
        2. 문제는 left, right로 타고 들어가는 것이었는데 이걸 재귀적으로 구현하는 것이 맞았음
        3. deque 자료형에 rotate라는 함수가 있어서 deque.rotate(1)이면 오른쪽으로 이동하고 맨 뒤에 있는 값이 앞으로 오고, rotate(-1)이면 왼쪽으로 이동하고 맨 앞에 있는 값이 맨 뒤로 이동한다는 것을 배움


6. 강의실 (1374)
    - 일자: 2024.07.01
    - 알고리즘: 힙/우선순위 큐
    - 고민: 40분
    - 코딩: 1시간
    - 답안 설명
        1.  시간초과로 실패
        2. 왜 우선순위 큐를 써야 시간이 줄어드는지 답안을 보고 알았음
    - 비교 설명
        0. 큐를 쓰면, NlogN을 쓰는 데 더해 또 리스트를 두 번 돌아야 해서 결국 O(N^2)으로 시간초과
        1. 반면, 우선순위큐를 쓰면 sorted로 정렬하는 데, O(NlogN) 시간을 사용. 여기에 더해 O(N) * O(logN)으로 결국 O(NlogN) 안에서 가능함
        2. 방법을 잘 생각해야 하는데, 시작시간과 끝 시간이 주어지는데, 힙으로는 끝시간만 저장하여 해결이 가능함
        3. 힙은 강의 종료시간을 기준으로 최소힙으로 유지
        4. 새로운 강의의 시작시간과 힙의 가장 작은 종료 시간을 비교해서 만일 힙의 가장 작은 종료 시간이 현재 강의 시작시간 전이라면, 가장 작은 종료 시간을 빼고 새로운 강의의 종료시간을 힙에 추가
        5. 그렇지 않다면, 새로운 강의는 현 시점에서 선택할 수 없으므로 힙에 종료시간만 추가
        6. s, e를 어떻게 고려해야 힙으로 쓸 수 있을지 몰라서 큐를 썼었는데, 이런 식으로 하나의 시간만 힙에 업데이트 하면 된다는 점을 깨달음


</details>



</details>



<details>
  <summary>Week 06</summary>
    <div>

### 구현
> 7주차 (2024.07.02 - 2024.07.08)

1. 2xn 타일링 2 (11727)
    - 일자: 2024.07.02
    - 알고리즘: DP
    - 고민: 30분
    - 코딩: 5분
    - 답안 설명
        1. 2x2 타일이 추가된 것을 못 보고 계속 예시 답안이랑 안 맞아서 머리 싸맴
        2. dp 구현을 메모이제이션 or 타뷸레이션을 썼던 것이 섞여서 생각났는데 여전히 개념이 덜 잡혀있는 것 같음
    
2. 퇴사 (14501)
    - 일자: 2024.07.03
    - 알고리즘: DP
    - 고민: 30분
    - 코딩: 15분
    - 답안 설명
        1. 깊이가 깊지 않아 2^15 정도길래 DFS로 풀었음 + DP로 접근을 못 하겠어서 DFS로 해결
        2. DP로 푼 사람을 보니 첫날이 아니라 마지막 날을 시작으로 해서 거꾸로 타고 들어가면서 기록
        3. 현재 상담을 했을 때 초과되면 다음날의 수익을 기록
        4. 상담을 했을 때 초과되지 않으면 (상담을 할 경우 넘어가는 날짜에 적힌 수익 + 현재 상담 수익)과 다음날짜 수익 중 max를 선택
        5. 이렇게가 아니더라도, 여러 방식으로 DP 구현이 가능

3. 주사위 굴리기 (14499)
    - 일자: 2024.07.04
    - 알고리즘: 구현
    - 고민: 45분
    - 코딩: 1시간 30분
    - 답안 설명
        1. 하... "0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다." 칸에 쓰여있는 수도 0이 된다는 이 조건 하나를 놓쳐서 한 시간을 넘게 썼다..
        2. 아무리 해도 x, y 위치도 맞고, 주사위도 잘 돌아가고 하는데 뭐가 문제인가 했는데..

4. 미세먼지 안녕! (17144)
    - 일자: 2024.
    - 알고리즘: 구현
    - 고민: 
    - 코딩: 
    - 설명
        1. 

5. 케빈 베이컨의 6단계 법칙 (1389)
    - 일자: 2024.
    - 알고리즘: DFS/BFS
    - 고민: 
    - 코딩: 
    - 답안 설명
        1. 

</details>