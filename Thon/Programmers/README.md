## Programmers

<details>
  <summary>Week 08</summary>
    <div>

> 8주차 (2024.07.08 - 2024.07.18)

1. 데이터 분석
    - 일자: 2024.07.18
    - 알고리즘: 기본
    - 고민: 5분
    - 코딩: 5분
    - 답안 설명
        1. label로 변수명을 설정해두고 인덱스를 찾아서 조건을 조회하는 방식으로 진행함
        2. 데이터 크기가 크지 않고 쉽게 생각이 가능해서 바로 풂

2. 이웃한 칸
    - 일자: 2024.07.18
    - 알고리즘: 기본
    - 고민: 3분
    - 코딩: 3분
    - 답안 설명
        1. dfs/bfs에서 좌표를 탐색하기 위해 나아가기 위한 첫번째 문제라 쉬웠음
        
3. 붕대 감기
    - 일자: 2024.07.18
    - 알고리즘: 구현
    - 고민: 19분
    - 코딩: 6분
    - 답안 설명
        1. t를 한 번씩 업데이트 하는 방법보다, attacks의 공격 시점을 queue로 생각해서 빼내고, 그 시점에 맞게 업데이트 하는 방식을 떠올림
        2. 이를 위해서는 회복 -> 공격 -> 시간 업데이트 순으로 구성해야 했음
        3. 단, 공격 시점에는 힐을 못하므로 1초를 빼도록 함

</details>


<details>
  <summary>Week 09</summary>
    <div>

> 9주차 (2024.07.22 - 2024.07.29)

1. 가장 많이 받은 선물
    - 일자: 2024.07.29
    - 알고리즘: 구현
    - 고민: 10분
    - 코딩: 25분
    - 답안 설명
        1. 딕셔너리를 써서 각 사람의 친구별 선물 횟수를 기록
        2. 딕셔너리를 써서 각 사람의 선물지수도 기록
        3. 이중 반복문으로 예측 결과 도출
        4. 인덱싱이 중요


</details>

<details>
  <summary> New Week 01</summary>
    <div>

> 1주차 (2024.09.05 - 2024.09.08)

1. 삼각 달팽이
    - 일자: 2024.09.05
    - 알고리즘: 구현/수학
    - 고민: 40분
    - 코딩: 15분
    - 답안 설명
        - 왼쪽 변을 지나갈 때는 계차수열로 해당 층(floor)값부터 아래로 갈수록 1씩 증가한 값을 차수로 더함
        - 아래 변을 지나갈 때는 등차수열로 증가 1씩 증가
        - 오른 변을 지나갈 때는 계차수열로 해당 층(floor)값부터 위로 갈수록 1씩 뺀 값 차수로 뺌
        - result = [0]에서 시작해서 이전의 값에 대해 해당되는 점화식을 계산하는 방식으로 해결
        - 이를 위해서는 n일 때 숫자 i가 해당하는 floor를 구하는 방법이 필요했는데, 반복문으로 딕셔너리에 저장
        - 달팽이 모양으로 변의 길이가 n에서 시작해서 0이 될 때까지 시행되므로 while문으로 n을 1씩 빼가며 반복문을 수행

2. 배달
    - 일자: 2024.09.06
    - 알고리즘: 다익스트라, 플로이드-워셜
    - 고민: 40분
    - 코딩: 30분
    - 답안 설명
        - 다익스트라 알고리즘은 heapq를 사용해, 최소힙을 꺼내서 최단 거리에 반영하는 방식
        - 이를 위해 heappush 할 때 (거리, 노드)로 저장해야 함 (첫번째 인덱스를 기준으로 해서)
        - 플로이드-워셜 방법은 삼중 반복문을 써서 중간 지점인 k가 있다고 하고 i-j와 i-k + k-j 중 작은 값을 저장하는 방식
        - 두 방식 모두 결과는 (N + 1) * (N + 1) 2차원 배열을 그려서 저장하며, 초기값으로는 inf를 설정

3. N-Queen
    - 일자: 2024.09.07
    - 알고리즘: 백트래킹, DFS
    - 고민: 30분
    - 코딩: 30분
    - 답안 설명
        - 완전탐색이 필요하나, 2차원 배열로 볼 경우 시간 초과 문제 발생
        - 백트래킹을 쓰면서도 1차원적으로 사용하는 영리함을 발휘해야 했음
        - 특히, 대각선 방향을 고려하기 위해서는 기울기를 생각해서 행과 행 사이의 거리와 열과 열 사이의 절댓값 거리를 고려하는 방식을 써야했는데, 이 방법은 죽어도 못 떠올렸을 것 같음
        - 이렇게 파고들다가 level == n이면 return 1 하고 cnt에 추가하는 방식
        - 또한, dfs 인자 중 하나로 리스트를 추가해서 다음 행의 퀸의 열 위치를 append함

</details>

<details>
  <summary> New Week 02</summary>
    <div>

> 2주차 (2024.09.09 - 2024.09.15)

1. 프렌즈4블록
    - 일자: 2024.09.09
    - 알고리즘: 구현
    - 고민: 40분
    - 코딩: 25분
    - 답안 설명
        - set으로 삭제 인덱스를 저장하되, 각 열별로 삭제해야 할 행 위치를 열 단위로 저장했다.
        - 빈 공간을 채우는 것은 string으로 바꾼 후 0인 공간을 replace하고, zfill을 쓰는 방식으로 해결했다.
        - 다만, transpose 과정이 필요했는데, 이를 좀 더 깔끔하게 하기 위해서 zip(*board)를 썼으면 좋았을 것 같다.

2. 파일명 정렬
    - 일자: 2024.09.10
    - 알고리즘: 문자열, 정렬
    - 고민: 10분
    - 코딩: 36분
    - 답안 설명
        - 문자열을 앞에서부터 pop하면서 HEAD 부분과 NUMBER 부분 구분, TAIL은 정렬에 쓰지 않아 저장 안 함
        - sorted의 key를 써서 HEAD, NORMAL 순서로 정렬
        - 정답을 보기 전에 일부 케이스에서 자꾸 안돼서 특수문자에서 실수했다고 생각하고 이 부분만 봤는데, 시간 낭비함..

3. n진수 게임
    - 일자: 2024.09.11
    - 알고리즘: 수학, 문자열
    - 고민: 15분
    - 코딩: 10분
    - 답안 설명
        - 10-15는 A-F로 대응시키기 위해 dict에서 끌어오는 방법 사용
        - 리스트는 나중에 join해야 되니까 문자열에 결과를 저장함
        - n진법은 divmod(i, n)을 i가 0이 될 때까지 시행하는 방식
        - 최종적으로 리스트 인덱싱을 활용해 답안 return

4. 후보키
    - 일자: 2024.09.12
    - 알고리즘: 완전탐색
    - 고민: 5분
    - 코딩: 30분
    - 답안 설명
        - 행과 열의 개수를 구한 후, 열의 조합을 사용해 풀이
        - 집합을 위주로 쓴 이유는 유일성 확인의 경우 중복된 행이 있으면 길이로 판단하기 위해서
        - 최소성을 확인하기 위해서는 지금 보고 있는 칼럼이 이미 등록된 적이 있는지 확인해야 했는데, 반복문으로 하나씩 확인함
        - 행의 개수가 최대 20이고 열의 개수가 최대 8개로 전체 조합을 고려해도 그 수가 많지 않아서 완전탐색으로 확인함

5. 스킬트리
    - 일자: 2024.09.13
    - 알고리즘: 큐
    - 고민: 5분
    - 코딩: 15분
    - 답안 설명
        - 선행 스킬과 관련 있는 스킬만 우선 남기고 차례대로 popleft해서 비교 (pop(0) 사용)
        - 근데 실수로, pop(0)를 안 하고 pop()을 써가지고 틀림
        - 테케에서는 다 맞는 거로 떠서, 실제 코테라면 그냥 틀렸을 것이라 주의 필요

6. 방문 길이
    - 일자: 2024.09.14
    - 알고리즘: 구현
    - 고민: 7분
    - 코딩: 8분
    - 답안 설명
        - 집합 자료형을 써서, x1, x2와 y1, y2를 모두 기록했다.
        - 양방향을 고려하기 위해서 저장할 때는 x1, x2와 y1, y2를 각각 정렬하는 방법을 사용했다.

7. 괄호 변환
    - 일자: 2024.09.15
    - 알고리즘: 스택, 큐, dfs
    - 고민: 30분
    - 코딩: 40분
    - 답안 설명
        - 주어진 작동 순서를 그대로 잘 따르는 것이 관건
        - 특히, 4단계 재귀적으로 v를 확인하고, u를 뒤집는다 이 말을 잘 읽고 수행해야 함
        - dfs의 인자 안에 문자열을 더해가며 푼 것은 처음인데 뭔가 이해가 갔다.
        - 다만, return을 잘 처리해야 했는데 실수를 했다
        - 그리고 재귀적인 u, v를 헷갈려서 잘 못 입력한 부분도 있어 어려웠다.
</details>

<details>
  <summary> New Week 02 </summary>
    <div>

> 2주차 (2024.09.16 - 2024.09.22)

1. 쿼드압축 후 개수 세기
    - 일자: 2024.09.17
    - 알고리즘: DFS
    - 고민: 40분
    - 코딩: 40분
    - 답안 설명
        - 나는 인덱싱을 활용하는 방식을 시도했으나 실패함
        - 정답을 보니, 깔끔하게 재귀함수를 사용함
        - start, end를 정하고 (start, end), (start, end + N), (start + N, end), (start + N, end + N) 네 가지 방향으로 타고 들어감
        - temp에 저장한 원소와 비교하여 같지 않으면 바로 그 아래 단위로 네 방향으로 타고 가면 된 다는 점을 배웠음

2. 메뉴 리뉴얼
    - 일자: 2024.09.18
    - 알고리즘: 완전 탐색
    - 고민: 30분
    - 코딩: 30분
    - 답안 설명
        - 최소 2명 이상이 주문한 최소 2가지 이상의 메뉴 조합을 전부 봐야 해서 combinations로 사람을 택하고 두 사람의 교집합을 확인하는 완전 탐색 사용
        - 사전 자료형을 써서 각 하위조합을 키로, 집합 자료형을 value로 하여 집합에 사람을 추가
        - 이 중에서 가장 많이 주문된 조합을 찾기 위해 key 문자열의 길이별로 len(value) 값이 가장 큰 조합을 저장해 나감
    - 답안 참고
        - Counter와 most_common() 메소드로 풀어 깔끔하게 푼 답안이 있었음
        - 나와 거의 동일한 방식이지만, combination 조합을 자동으로 Counter로 저장하는 깔끔함이 좋았음
        - 그리고 most_common의 인자에 대해서 n을 입력하면 최빈값 n개를 찾아주는데 입력하지 않으면 내림차순으로 반환함
        - 이를 적극 활용하는 것이 인상적이었음. 까먹지 말고 나도 쓰자.

</details>

<details>
  <summary> New Week 03 </summary>
    <div>

> 3주차 (2024.09.23 - 2024.09.29)

1. 거리두기 확인하기
    - 일자: 2024.09.25
    - 알고리즘: dfs
    - 고민: 15분
    - 코딩: 15분
    - 답안 설명
        - 사람의 위치를 미리 저장해둠
        - dfs로 들어가되, level 2에 도달하면 종료
        - dfs로 들어가되 level 2 미만인 시점에서
            - 움직이고자 하는 다음 노드가 P이면 결과를 False로 두고 return
            - 다음 노드가 X이면 continue로 다른 움직일 위치를 봄
            - 다음 노드가 O이면 visited에 기록하고 다음 level로 넘어감
        - result가 False로 나온 경우에는 바로 거리두기 0으로 기록

2. 두 큐 합 같게 만들기
    - 일자: 2024.09.26
    - 고민: 20분
    - 코딩: 40분
    - 답안 설명
        - 처음에는 투 포인터 느낌으로 풀려 했으나, 인덱스 위치는 찾았는데 pop을 카운트할 방법을 못 생각함
        - 당황해서 다시 큐로 풀기로 돌아옴
        - 큐로 풀 때, 답은 잘 구했으나 시간복잡도 문제에 봉착 -> sum() 함수가 O(N) 복잡도 가지는데 이것을 계속 써서 이중 반복 효과가 발생해버림
        - 그리고, 카운트 횟수를 제한하고자 q1, q2 길이의 합을 썼는데 q1이 한 번 더 빠지는 것을 고려해서 q1 길이 * 2 + q2 길이를 제한으로 써야했음
        - 함수의 시간복잡도를 고려하여 현명한 풀이를 할 줄 알아야 한다는 것을 배움

</details>

<details>
  <summary> New Week 04-05 </summary>
    <div>

> 4주차 (2024.09.30 - 2024.10.13)

1. 택배상자
    - 일자: 2024.10.03
    - 알고리즘: 스택/큐
    - 고민: 35분
    - 코딩: 10분
    - 답안 설명
        - 총 4가지 과정이 가능 컨베이어벨트에서 나오는 과정 = popleft, 보조벨트에 싣는 과정 = append, 보조벨트에서 빼기 = pop, 최종택배차에 싣기 = append
        - 각 과정은 조건에 따라 시행되는데, 조건은 먼저 보조벨트의 마지막 값이 order의 첫번째 값과 일치하는지가 우선돼야 했음
        - 그 다음, 벨트의 첫번째 값이 order의 첫번째 값과 같은지 비교
        - 위 둘 다 아니라면 belt의 첫번째 값을 conv로 옮기는 과정으로 종료가 가능
        - 이렇게 하되, break 조건으로 belt가 비지않거나 (보조벨트에 상자가 있고, 보조벨트의 마지막 상자가 order와 같으면) 계속 while문이 돌아가게 했음

2. 혼자 놀기의 달인
    - 일자: 2024.10.07
    - 고민: 15분
    - 코딩: 10분
    - 답안 설명
        - cards의 각 값에서 일단 1을 빼서 인덱싱을 수월하게 만듦
        - 카드의 그룹을 찾는 것을 목표로 했음
        - 이를 while문을 이중으로 구성해도 충분히 시간복잡도가 낮아서 그대로 함
        - 안쪽의 while문에 대해서는 집합 자료형을 써서 그룹의 인덱스를 기록하도록 하고 중복이 발생할 경우 break 조건을 걸었음
        - 바깥쪽의 while문에서는 tmp를 새롭게 찾고, 시작점으로 두게 하고, 길이를 기록하는 방식을 씀

</details>


<details>
  <summary> New Week 0n template</summary>
    <div>

> n주차 (2024.09. - 2024.09.)

1. 
    - 일자: 2024.09.
    - 알고리즘:
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

2. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

3. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 
4. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

5. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

6. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

7. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 
</details>