## Programmers

<details>
  <summary>Week 08</summary>
    <div>

> 8주차 (2024.07.08 - 2024.07.18)

1. 데이터 분석
    - 일자: 2024.07.18
    - 알고리즘: 기본
    - 고민: 5분
    - 코딩: 5분
    - 답안 설명
        1. label로 변수명을 설정해두고 인덱스를 찾아서 조건을 조회하는 방식으로 진행함
        2. 데이터 크기가 크지 않고 쉽게 생각이 가능해서 바로 풂

2. 이웃한 칸
    - 일자: 2024.07.18
    - 알고리즘: 기본
    - 고민: 3분
    - 코딩: 3분
    - 답안 설명
        1. dfs/bfs에서 좌표를 탐색하기 위해 나아가기 위한 첫번째 문제라 쉬웠음
        
3. 붕대 감기
    - 일자: 2024.07.18
    - 알고리즘: 구현
    - 고민: 19분
    - 코딩: 6분
    - 답안 설명
        1. t를 한 번씩 업데이트 하는 방법보다, attacks의 공격 시점을 queue로 생각해서 빼내고, 그 시점에 맞게 업데이트 하는 방식을 떠올림
        2. 이를 위해서는 회복 -> 공격 -> 시간 업데이트 순으로 구성해야 했음
        3. 단, 공격 시점에는 힐을 못하므로 1초를 빼도록 함

</details>


<details>
  <summary>Week 09</summary>
    <div>

> 9주차 (2024.07.22 - 2024.07.29)

1. 가장 많이 받은 선물
    - 일자: 2024.07.29
    - 알고리즘: 구현
    - 고민: 10분
    - 코딩: 25분
    - 답안 설명
        1. 딕셔너리를 써서 각 사람의 친구별 선물 횟수를 기록
        2. 딕셔너리를 써서 각 사람의 선물지수도 기록
        3. 이중 반복문으로 예측 결과 도출
        4. 인덱싱이 중요


</details>

<details>
  <summary> New Week 01</summary>
    <div>

> 1주차 (2024.09.05 - 2024.09.08)

1. 삼각 달팽이
    - 일자: 2024.09.05
    - 알고리즘: 구현/수학
    - 고민: 40분
    - 코딩: 15분
    - 답안 설명
        - 왼쪽 변을 지나갈 때는 계차수열로 해당 층(floor)값부터 아래로 갈수록 1씩 증가한 값을 차수로 더함
        - 아래 변을 지나갈 때는 등차수열로 증가 1씩 증가
        - 오른 변을 지나갈 때는 계차수열로 해당 층(floor)값부터 위로 갈수록 1씩 뺀 값 차수로 뺌
        - result = [0]에서 시작해서 이전의 값에 대해 해당되는 점화식을 계산하는 방식으로 해결
        - 이를 위해서는 n일 때 숫자 i가 해당하는 floor를 구하는 방법이 필요했는데, 반복문으로 딕셔너리에 저장
        - 달팽이 모양으로 변의 길이가 n에서 시작해서 0이 될 때까지 시행되므로 while문으로 n을 1씩 빼가며 반복문을 수행

2. 배달
    - 일자: 2024.09.06
    - 알고리즘: 다익스트라, 플로이드-워셜
    - 고민: 40분
    - 코딩: 30분
    - 답안 설명
        - 다익스트라 알고리즘은 heapq를 사용해, 최소힙을 꺼내서 최단 거리에 반영하는 방식
        - 이를 위해 heappush 할 때 (거리, 노드)로 저장해야 함 (첫번째 인덱스를 기준으로 해서)
        - 플로이드-워셜 방법은 삼중 반복문을 써서 중간 지점인 k가 있다고 하고 i-j와 i-k + k-j 중 작은 값을 저장하는 방식
        - 두 방식 모두 결과는 (N + 1) * (N + 1) 2차원 배열을 그려서 저장하며, 초기값으로는 inf를 설정

3. N-Queen
    - 일자: 2024.09.07
    - 알고리즘: 백트래킹, DFS
    - 고민: 30분
    - 코딩: 30분
    - 답안 설명
        - 완전탐색이 필요하나, 2차원 배열로 볼 경우 시간 초과 문제 발생
        - 백트래킹을 쓰면서도 1차원적으로 사용하는 영리함을 발휘해야 했음
        - 특히, 대각선 방향을 고려하기 위해서는 기울기를 생각해서 행과 행 사이의 거리와 열과 열 사이의 절댓값 거리를 고려하는 방식을 써야했는데, 이 방법은 죽어도 못 떠올렸을 것 같음
        - 이렇게 파고들다가 level == n이면 return 1 하고 cnt에 추가하는 방식
        - 또한, dfs 인자 중 하나로 리스트를 추가해서 다음 행의 퀸의 열 위치를 append함

</details>

<details>
  <summary> New Week 02</summary>
    <div>

> 2주차 (2024.09.09 - 2024.09.15)

1. 프렌즈4블록
    - 일자: 2024.09.09
    - 알고리즘: 구현
    - 고민: 40분
    - 코딩: 25분
    - 답안 설명
        - set으로 삭제 인덱스를 저장하되, 각 열별로 삭제해야 할 행 위치를 열 단위로 저장했다.
        - 빈 공간을 채우는 것은 string으로 바꾼 후 0인 공간을 replace하고, zfill을 쓰는 방식으로 해결했다.
        - 다만, transpose 과정이 필요했는데, 이를 좀 더 깔끔하게 하기 위해서 zip(*board)를 썼으면 좋았을 것 같다.

2. 파일명 정렬
    - 일자: 2024.09.10
    - 알고리즘: 문자열, 정렬
    - 고민: 10분
    - 코딩: 36분
    - 답안 설명
        - 문자열을 앞에서부터 pop하면서 HEAD 부분과 NUMBER 부분 구분, TAIL은 정렬에 쓰지 않아 저장 안 함
        - sorted의 key를 써서 HEAD, NORMAL 순서로 정렬
        - 정답을 보기 전에 일부 케이스에서 자꾸 안돼서 특수문자에서 실수했다고 생각하고 이 부분만 봤는데, 시간 낭비함..

3. n진수 게임
    - 일자: 2024.09.11
    - 알고리즘: 수학, 문자열
    - 고민: 15분
    - 코딩: 10분
    - 답안 설명
        - 10-15는 A-F로 대응시키기 위해 dict에서 끌어오는 방법 사용
        - 리스트는 나중에 join해야 되니까 문자열에 결과를 저장함
        - n진법은 divmod(i, n)을 i가 0이 될 때까지 시행하는 방식
        - 최종적으로 리스트 인덱싱을 활용해 답안 return

4. 후보키
    - 일자: 2024.09.12
    - 알고리즘: 완전탐색
    - 고민: 5분
    - 코딩: 30분
    - 답안 설명
        - 행과 열의 개수를 구한 후, 열의 조합을 사용해 풀이
        - 집합을 위주로 쓴 이유는 유일성 확인의 경우 중복된 행이 있으면 길이로 판단하기 위해서
        - 최소성을 확인하기 위해서는 지금 보고 있는 칼럼이 이미 등록된 적이 있는지 확인해야 했는데, 반복문으로 하나씩 확인함
        - 행의 개수가 최대 20이고 열의 개수가 최대 8개로 전체 조합을 고려해도 그 수가 많지 않아서 완전탐색으로 확인함

5. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

6. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

7. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 
</details>

<details>
  <summary> New Week 0n template</summary>
    <div>

> n주차 (2024.09. - 2024.09.)

1. 
    - 일자: 2024.09.
    - 알고리즘:
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

2. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

3. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 
4. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

5. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

6. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 

7. 
    - 일자: 2024.09.
    - 알고리즘: 
    - 고민: 분
    - 코딩: 분
    - 답안 설명
        - 
</details>